# #4093: LICM pass stopped working

- **URL:** https://github.com/WebAssembly/binaryen/issues/4093
- **Author:** MaxGraey
- **Created:** 2021-08-18
- **Updated:** 2021-08-30

## Description

After some of this changes: #4059 or #4077 or #4076

LICM pass stopped working.

Here minimal example:
```ts
export function loop1(n: i32, ptr: usize): void {
  let acc = 0;
  for (let i = 0; i < n; i++) {
    acc += load<i32>(ptr);
  }
}
```
Unoptimized version (original):
```wat
(module
 (type $i32_i32_=>_none (func (param i32 i32)))
 (memory $0 0)
 (export "loop1" (func $loop-test/loop1))
 (export "memory" (memory $0))
 (func $loop-test/loop1 (param $0 i32) (param $1 i32)
  (local $2 i32)
  (local $3 i32)
  (local $4 i32)
  i32.const 0
  local.set $2
  i32.const 0
  local.set $3
  loop $for-loop|0
   local.get $3
   local.get $0
   i32.lt_s
   local.set $4
   local.get $4
   if
    local.get $2
    local.get $1
    i32.load
    i32.add
    local.set $2
    local.get $3
    i32.const 1
    i32.add
    local.set $3
    br $for-loop|0
   end
  end
 )
)
```
Optimized:
```wat
(module
 (type $i32_i32_=>_none (func (param i32 i32)))
 (memory $0 0)
 (export "loop1" (func $loop-test/loop1))
 (export "memory" (memory $0))
 (func $loop-test/loop1 (param $0 i32) (param $1 i32)
  (local $2 i32)
  (local $3 i32)
  loop $for-loop|0
   local.get $0
   local.get $2
   i32.gt_s
   if
    local.get $1
    i32.load
    local.get $3
    i32.add
    local.set $3
    local.get $2
    i32.const 1
    i32.add
    local.set $2
    br $for-loop|0
   end
  end
 )
)
```
Expected:
```wat
(module
 (type $i32_i32_=>_none (func (param i32 i32)))
 (memory $0 0)
 (export "loop1" (func $module/loop1))
 (export "memory" (memory $0))
 (func $module/loop1 (param $0 i32) (param $1 i32)
  (local $2 i32)
  (local $3 i32)
  local.get $1
  i32.load
  local.set $1
  loop $for-loop|0
   local.get $0
   local.get $2
   i32.gt_s
   if
    local.get $1
    local.get $3
    i32.add
    local.set $3
    local.get $2
    i32.const 1
    i32.add
    local.set $2
    br $for-loop|0
   end
  end
 )
)
```

## Comments (17)

### kripken (2021-08-18)

Hmm, none of those PRs seem directly relevant. Can you bisect to find the bad commit?

---

### kripken (2021-08-18)

(Fair point in the previous PR about wasm interpreters benefiting from LICM, even if optimizing compilers don't.)

---

### MaxGraey (2021-08-19)

> (Fair point in the previous PR about wasm interpreters benefiting from LICM, even if optimizing compilers don't.)

By the way, this also includes blockchains that use single-pass AOT compilers like "lightbeam" (part of wasmtime) or wasmi interpreter.

---

### MaxGraey (2021-08-19)

Hmm. I already simplified this to:
```wat
(module
  (type $t0 (func (param i32)))
  (func $loop1 (export "loop1") (type $t0) (param $p0 i32)
    (local $l0 i32) (local $l1 i32)
    loop $L0
      get_local $p0
      get_local $l0
      i32.gt_s
      if $I1
        i32.const 123
        i32.load
        drop
        get_local $l1
        i32.const 1
        i32.add
        set_local $l1
        get_local $l0
        i32.const 1
        i32.add
        set_local $l0
        br $L0
      end
    end)
  (memory $memory (export "memory") 0))
```
and compile as `./bin/wasm-opt ./bin/test.wasm -all --ssa-nomerge --simplify-locals-notee-nostructure --flatten --vacuum --licm -O4 -o ./bin/test.opt.wat -S` but it still can't apply LICM:
```wat
(module
 (type $i32_=>_none (func (param i32)))
 (memory $0 0)
 (export "loop1" (func $0))
 (export "memory" (memory $0))
 (func $0 (; has Stack IR ;) (param $0 i32)
  (local $1 i32)
  (local $2 i32)
  (loop $label$1
   (if
    (i32.gt_s
     (local.get $0)
     (local.get $1)
    )
    (block
     (drop
      (i32.load
       (i32.const 123)
      )
     )
     (local.set $2
      (i32.add
       (local.get $2)
       (i32.const 1)
      )
     )
     (local.set $1
      (i32.add
       (local.get $1)
       (i32.const 1)
      )
     )
     (br $label$1)
    )
   )
  )
 )
 ;; custom section "sourceMappingURL", size 16
)
```

---

### MaxGraey (2021-08-19)

Hmm, It seems LICM anly works for such simple cases without inner blocks:
```ts
while (true) {
   load<i32>(123);
}
```

---

### kripken (2021-08-19)

Yes, see this comment in the code:
```cpp
    // Walk along the loop entrance, while all the code there
    // is executed unconditionally. That is the code we want to
    // move out - anything that might or might not be executed
    // may be best left alone anyhow.
```
The load is inside the if body, so it ignores it.

It may be a good idea to extend LICM to handle such things. There is some risk though, as if the loop executes without entering the if, doing the load before the loop is wasteful. I'm curious what other compilers do for that.

---

### MaxGraey (2021-08-19)

Yeah. That's more tricky. LLVM do something like this:

```cpp
for (int i = 0; <cond> ; i++) { // i - induction
   <variant code> <invariant code>
}
```

transforms to:
```cpp
int i = 0;
if (<cond>) {
  <invariant code>
  do {
     i++;
     <variant code>
  } while (<cond>)
}
```

https://godbolt.org/z/xhYf6PEnq

---

### MaxGraey (2021-08-19)

It seems I bisected it!

run as: 
``` bash
./bin/wasm-opt ./bin/test.wasm -all --ssa-nomerge --simplify-locals-notee-nostructure --flatten --vacuum --local-cse --licm -O4 -o ./bin/test.opt.wat -S 
```

NOTE: without old `local-cse` pass before `licm` this will not properly work

  Original example `test.wasm`:  
```wat
  (module
 (type $i32_=>_i32 (func (param i32) (result i32)))
 (memory $0 0)
 (table $0 1 funcref)
 (export "whileAny" (func $main/whileAny))
 (export "memory" (memory $0))
 (func $main/whileAny (param $0 i32) (result i32)
  (local $1 i32)
  (block $while-break|0
   (loop $while-continue|0
    (local.set $1
     (i32.const 1)
    )
    (if
     (local.get $1)
     (block
      (if
       (i32.eq
        (local.get $0)
        (i32.const 1)
       )
       (block
        (return
         (i32.const 1)
        )
        (unreachable)
       )
       (block
        (if
         (i32.eq
          (local.get $0)
          (i32.const 2)
         )
         (block
          (return
           (i32.const 2)
          )
          (unreachable)
         )
         (block
          (br $while-continue|0)
          (unreachable)
         )
        )
        (unreachable)
       )
      )
      (unreachable)
      (unreachable)
     )
    )
   )
  )
  (unreachable)
 )
)
```

  currently with latest main wasm-opt produce this (without code motion): 
  
```wat
 (module
 (type $i32_=>_i32 (func (param i32) (result i32)))
 (memory $0 0)
 (export "whileAny" (func $0))
 (export "memory" (memory $0))
 (func $0 (; has Stack IR ;) (param $0 i32) (result i32)
  (loop $label$2 (result i32)
   (if (result i32)
    (i32.eq
     (local.get $0)
     (i32.const 1)
    )
    (i32.const 1)
    (if (result i32)
     (i32.eq
      (local.get $0)
      (i32.const 2)
     )
     (i32.const 2)
     (br $label$2)
    )
   )
  )
 )
)  
```
with old local-cse and same wasm-opt with LICM pass it was worked:
```wat
  (module
 (type $i32_=>_i32 (func (param i32) (result i32)))
 (memory $0 0)
 (export "whileAny" (func $main/whileAny))
 (export "memory" (memory $0))
 (func $main/whileAny (param $0 i32) (result i32)
  (local $1 i32)
  (local.set $1
   (i32.eq
    (local.get $0)
    (i32.const 1)
   )
  )
  (loop $while-continue|0 (result i32)
   (if (result i32)
    (local.get $1)
    (i32.const 1)
    (block (result i32)
     (br_if $while-continue|0
      (i32.ne
       (local.get $0)
       (i32.const 2)
      )
     )
     (i32.const 2)
    )
   )
  )
 )
)
```

---

### kripken (2021-08-20)

Interesting, thanks!

What seems to happen here is that we start like this:
```wat
  (loop $while-continue|0
   (block
    (local.set $1
     (local.get $0)
    )
    (local.set $2
     (i32.eq
      (local.get $1)
      (i32.const 1)
     )
    )
```
Note that we can't move the second set of the loop, as it uses `$1` which is written right before it. However, if we use the fact that that is a copy, then we could write
```wat
  (loop $while-continue|0
   (block
    (local.set $1
     (local.get $0)
    )
    (local.set $2
     (i32.eq
      (local.get $0) ;; this is the only change
      (i32.const 1)
     )
    )
```
Then that could be moved out. `--simplify-locals-notee-nostructure` does this, but it does more:
```wat
  (loop $while-continue|0
   (block
    (nop)
    (nop)
    (if
     (i32.eq
      (local.get $0)
      (i32.const 1)
     )
```
By moving that `i32.eq` into the if condition, it is in a place where LICM can't see it.

This worked before because the old LocalCSE ran an "equivalent locals" operation using the `EquivalentSets` helper. SimplifyLocals runs it too, but does a lot more.

I'm not sure if this matters enough to fix - because LocalCSE in general seems low priority to me. This is kind of a corner case. But, if we do want to fix it, two options are:

* Add a new pass that just does the `EquivalentSets` stuff. That's already mostly in a helper - which is how LocalCSE could do it - so that's feasible. And then we would not run simplify-locals right before LICM, but just the new pass.
* Teach LICM to look at more things than the top level of the block, like an if condition. That would be more work, though.

---

### MaxGraey (2021-08-21)

> And then we would not run simplify-locals right before LICM, but just the new pass.

Unfortunately this doesn't help. I tried this combinations:
```js
...
"flatten"
"vacuum"
"simplify-locals-notee-nostructure" // also simplify-locals-notee and simplify-locals
"licm"
...
```
Unfortunately it didn't help

---

### kripken (2021-08-21)

Sorry if I wasn't clear, I meant "the new pass" to mean a hypothetical new pass that just does the `EquivalentSets` stuff. That doesn't exist so it is not testable right now.

Meanwhile, another variation on option 1 (a hypothetical new pass) is not a totally new pass but a variation on `simplify-locals` which does not move code past control flow boundaries. We already have "notee" etc. variations, so this would be just another kind. This might be useful for other things than this issue, like non-nullable locals (where one proposal is to have them be limited by control flow blocks).

---

### MaxGraey (2021-08-21)

Ah, I see.

> This might be useful for other things than this issue, like non-nullable locals (where one proposal is to have them be limited by control flow blocks).

It would be great to have such pass

---

### MaxGraey (2021-08-25)

With dominator tree #4100 will be possible to implement a better analysis of loops as well as their optimization including a more advanced LICM pass. Do I understand correctly?

---

### kripken (2021-08-26)

Yes, some passes like LICM might use dominance to be more general. It wouldn't help with this specific minor issue here, but could allow LICM of more code than the first basic block in the loop.

---

### MaxGraey (2021-08-27)

I see, Thanks. What about other loop optimizations? Like Loop fusion? This should potentially reduce the size of binary

---

### kripken (2021-08-30)

I don't have plans to work on loop fusion myself. But if there were data on its importance that could change.

---

### MaxGraey (2021-08-30)

I guess it could be useful for J2CL which doesn't apply any optimizations for loops. But loop fusion could enhance size and speed (cache locality). 90% of the execution time of a computer program is spent executing 10% of the code (90/10 law). But while vm runtimes usually do some simple loop unrolling and licm transforms. I'm not sure about Loop's peeling and loop fusion.

---

