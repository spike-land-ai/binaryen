# #3313: Fatal: Module::addExport: empty name when using binaryen.js

- **URL:** https://github.com/WebAssembly/binaryen/issues/3313
- **Author:** dcodeIO
- **Created:** 2020-11-01
- **Updated:** 2020-11-30

## Description

Using a release version of Binaryen.js, I am (sometimes) hitting an assertion `Fatal: Module::addExport: empty name` when calling the C API's `_BinaryenAddGlobalExport`:

```js
  addGlobalExport(
    internalName: string,
    externalName: string
  ): ExportRef {
    var cStr1 = this.allocStringCached(internalName);
    var cStr2 = this.allocStringCached(externalName);
    console.log(internalName, cStr1, readString(cStr1), externalName, cStr2, readString(cStr2));
    return binaryen._BinaryenAddGlobalExport(this.ref, cStr1, cStr2);
  }
```

logging

```
src/types/Type.i64 6075288 src/types/Type.i64 Type.i64 16669480 Type.i64
```

indicating that the string arguments are not empty (or null) and can be read back properly.

The error goes away when using a debug build with https://github.com/WebAssembly/binaryen/pull/3311 applied.

## Comments (3)

### dcodeIO (2020-11-01)

Same error when disabling `--closure` and disabling `-flto`. The error goes away when switching optimization levels from `-Oz` to `-O2` or `-O3`, but still happens in `-Os`. [binaryen.zip](https://github.com/WebAssembly/binaryen/files/5471474/binaryen.zip)

---

### dcodeIO (2020-11-30)

Still haven't managed to find out how this happens, but it appears that it somehow depends on how big the module being generated already is (or how many exports it has). Early on the error rarely happens, but at some threshold of exports it starts happening at what appears to be randomly.

The observation that disabling optimizations for size and instead compiling binaryen.js with `-O2` still holds. I'm using a custom build like that successfully so far. Interestingly, when using an affected `-Oz` build, not caching allocations (the AS compiler caches strings it provides to the C-API and frees them all at once when done) appears to delay the problem for a bit before it starts occurring again.

---

### tlively (2020-11-30)

This does seem like maybe it's related to memory growth. Would it be possible to log memory growth events to test that hypothesis? From looking at the Emscripten source, it looks like `-sEMSCRIPTEN_TRACING` might print relevant information.

---

