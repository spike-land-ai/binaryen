# #7458: O2 regression in optimize-instructions due to coalesceLocals

- **URL:** https://github.com/WebAssembly/binaryen/issues/7458
- **Author:** xuruiyang2002
- **Created:** 2025-04-07
- **Updated:** 2025-04-09

## Description

Given the following code:

``` webassembly
(module
  (import "External" "external_function" (func $external_function))
  (func $_start
    (local $0 i32) (local $3 i32) (local $5 i32) (local $6 i32) (local $11 i32) (local $1 i32) (local $2 i32) (local $7 i32)
    loop ;; label = @1
      block ;; label = @2
        i32.const 0
        i32.load
        br_if 0 (;@2;)
        i32.const 0
        local.get $11
        i32.store
        i32.const 0
        local.set $5
        i32.const 1
        local.set $0
        i32.const 0
        local.get $0
        i32.store
        i32.const -346457217
        local.set $6
        block ;; label = @3
          local.get $0
          local.get $6
          i32.ne
          br_if 0 (;@3;)
          call $external_function
        end
        local.get $5
        i32.const 0
        i32.load
        i32.lt_s
        i32.const 0
        local.set $1
        local.get $1
        i32.shl
        drop
        local.get $1
        unreachable
      end
      i32.const 0
      i32.load
      local.set $2
      local.get $2
      local.set $3
      local.get $2
      local.get $3
      i32.store
      br 0 (;@1;)
    end)
  (memory $0 1)
  (export "_start" (func $_start)))
```

`wasm-opt` (16dbac1) can eliminate the dead `br_if` body by `-all -O1` but cannot by `-all -O2`.

### Analysis

The direct issue is that `optimize-instructions` cannot deduce the condition to zero in `-all -O2` while it can in `-all -O1`. (further the dead `if` statement body will be eliminated by `--vacuum`)

Before  `optimize-instructions`, that is `precompute`:


<details>
<summary>`-all -O1`, after `precompute`, going to `optimize-instructions`</summary>

```webassembly
(module
  (type (;0;) (func))
  (import "External" "external_functional" (func (;0;) (type 0)))
  (func (;1;) (type 0)
    (local i32 i32)
    loop  ;; label = @1
      i32.const 0
      i32.load
      i32.eqz
      if  ;; label = @2
        i32.const 0
        local.get 1
        i32.store
        i32.const 0
        i32.const 1
        local.tee 0
        i32.store
        local.get 0
        i32.const -346457217
        i32.eq
        if  ;; label = @3
          call 0
        end
        i32.const 0
        i32.load
        drop
        unreachable
      else
        i32.const 0
        i32.load
        local.tee 1 ;; Note this line: using variable 1, not affects condition
        local.get 1
        i32.store
        br 1 (;@1;)
      end
      unreachable
    end
    unreachable)
  (memory (;0;) 1)
  (export "_start" (func 1)))
```
</details>
<details>
<summary>`-all -O2`, after `precompute`, going to `optimize-instructions`</summary>

```webassembly
(module
  (type (;0;) (func))
  (import "External" "external_function" (func (;0;) (type 0)))
  (func (;1;) (type 0)
    (local i32 i32)
    loop  ;; label = @1
      i32.const 0
      i32.load
      i32.eqz
      if  ;; label = @2
        i32.const 0
        local.get 1
        i32.store
        i32.const 0
        i32.const 1
        local.tee 0
        i32.store
        local.get 0
        i32.const -346457217
        i32.eq
        if  ;; label = @3
          call 0
        end
        i32.const 0
        i32.load
        unreachable
      else
        i32.const 0
        i32.load
        local.tee 0 ;; Note this line: using variable 0 will affect condition deduction
        local.get 0
        i32.store
        br 1 (;@1;)
      end
      unreachable
    end
    unreachable)
  (memory (;0;) 1)
  (export "_start" (func 1)))
```

</details>


As you can see, the condition are the same:

``` webassembly
(if
 (i32.eq
  (local.get $0) 
  (i32.const -346457217)
 )
 (then
  (call $external_functional)
 )
)
```

However, the statements in `else` statements are **slightly different, but critical**: `-all -O1` uses local variable 1, while `-all -O2` uses local variable 0 (`local.tee 0`), which I thinks maybe affect the deduction of the condition in `optimize-instructions` .

Continue to trace back and analyze in the optimized pipeline, **the slightly but critical difference begins in `coalesce-locals`**, which is the optimizations of `Key "register allocation" pass. Does a live range analysis and then reuses locals in order to minimize their number, as well as to remove copies between them.`

Although the `coalesce-locals` performs aggressive optimizations, I think there is missed optimization in the `optimize-instructions`, for it should have deduced the condition to be 0.


## Comments (2)

### kripken (2025-04-07)

I suspect coalesce-locals is causing us to use fewer locals, which happens to make some redundant optimizations not work. If say a local has a single use, then we can infer its value in more places, so coalescing locals hurts because a single local ends up with more work. However, the proper solution to this is to track local values, which takes a little more work, so we only do it in `-O3` (things like precompute-propagate).

I'm not sure I can think of a good thing to do here. I agree it is not good that `-O2` does worse than `-O1`, but this just seems like very bad luck in `-O2` which tries to be faster than `-O3` but do more than `-O1`, and in this case fails. (Problems in `-O3` would concern me more, or consistent/common issues in `-O2`.)

---

### xuruiyang2002 (2025-04-09)

Thatâ€™s an interesting observation. It seems like it's a corner case where coalesce-locals might lead to unexpected consequences. 

Anyway, since the `-O3` is the most concern, we'd focus on ensuring `-O3` performs well. If this issue becomes a more common issue, we can revisit with more comprehensive solutions.

---

