# #2414: Machine-generate instruction implementation code?

- **URL:** https://github.com/WebAssembly/binaryen/issues/2414
- **Author:** kripken
- **Created:** 2019-11-01
- **Updated:** 2019-11-06

## Description

I think we can simplify the checklist of things to do for new instructions,

https://github.com/WebAssembly/binaryen/blob/master/Contributing.md#adding-support-for-new-instructions

We already generate the wast parser using a python script. We can do something similar for core C++ code, generating code for each of the items in that list, starting from a high level declarative format something like
```
{
  "classes": [
    {
      "name": "Binary",
      "fields": [
        { "name": "op", "type": "BinaryOp" },
        { "name": "left", "type": "Expression*" },
        { "name": "right", "type": "Expression*" }
      }
    }
  ]
}
```
Practically speaking, we can create the declaration file, then implement the items in that checklist one by one in separate PRs (no need for a single huge change).

Thoughts?

## Comments (2)

### tlively (2019-11-05)

There are two levels of items for which we could generate code: instruction classes and individual instructions. Your example data would generate an instruction class, but since there are many more individual instructions than instruction classes, I think it would make sense to start by generating code for individual instructions.

These are the steps for adding a new instruction class:
 - Add instruction class to src/wasm.h
 - Add support in src/wasm-builder.h
 - Add support in wasm-traversal.h
 - Hashing and copying in src/ir/ExpressionAnalyzer.cpp
 - C API creation and querying support

Once the new instruction class is added to wasm-traversal.h, the compiler will point out other important places where it needs to be handled.

The steps for adding new instructions to existing classes are:
 - Add opcode to src/wasm.h
 - Interpretation added to src/wasm-interpreter.h
 - Parsing added in scripts/gen-s-parser.py and src/wasm/wasm-s-parser.cpp
 - Printing added in src/passes/Print.cpp
 - Decoding added in src/wasm-binary.h and src/wasm/wasm-binary.cpp
 - Binary writing added in src/wasm-stack.h and src/wasm/wasm-stack.cpp
 - Support added to src/tools/fuzzing.h
 - C API support added in src/binaryen-c.h and src/binaryen-c.cpp
 - JS API support added in build-js.sh and src/js/binaryen.js-post.js
 - C API tested in test/example/c-api-kitchen-sink.c
 - JS API tested in test/binaryen.js/kitchen-sink.js
 - Tests added in top-level test/

I think a gradual approach would be great. Also, I think it has worked well for the parser generator script to just have the data encoded in a literal python data structure rather than being parsed in from some other format.

---

### kripken (2019-11-06)

Good point, yeah, starting there might give bigger wins early.

---

