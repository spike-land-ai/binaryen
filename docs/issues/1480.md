# #1480: wasm2asm miscompiles nested i64 ops

- **URL:** https://github.com/WebAssembly/binaryen/issues/1480
- **Author:** froydnj
- **Created:** 2018-03-16
- **Updated:** 2018-03-19

## Description

Compiling a function like:

```wast
  (func $shl_i64 (param $0 i64) (param $1 i64) (result i64)
    (i64.or (i64.shl (get_local $0) (get_local $1))
	    (i64.shl (get_local $0) (get_local $1))))
```

results in:

```js
 function shl_i64($0, $0$hi, $1, $1$hi) {
  $0 = $0 | 0;
  $0$hi = $0$hi | 0;
  $1 = $1 | 0;
  $1$hi = $1$hi | 0;
  var i64toi32_i32$0 = 0, i64toi32_i32$1 = 0, i64toi32_i32$2 = 0, i64toi32_i32$3 = 0, i64toi32_i32$4 = 0, i64toi32_i32$5 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0;
  i64toi32_i32$0 = $0$hi;
  i64toi32_i32$2 = $0;
  i64toi32_i32$1 = $1$hi;
  i64toi32_i32$3 = $1;
  i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;
  if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {
   i64toi32_i32$1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
   $45 = 0;
  } else {
   i64toi32_i32$1 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$4 | 0) | 0;
   $45 = i64toi32_i32$2 << i64toi32_i32$4 | 0;
  }
  // XXX
  i64toi32_i32$3 = $45;
  i64toi32_i32$2 = $0$hi;
  i64toi32_i32$3 = $0;
  i64toi32_i32$0 = $1$hi;
  i64toi32_i32$4 = $1;
  i64toi32_i32$5 = i64toi32_i32$4 & 31 | 0;
  if (32 >>> 0 <= (i64toi32_i32$4 & 63 | 0) >>> 0) {
   i64toi32_i32$0 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
   $84 = 0;
  } else {
   i64toi32_i32$0 = ((1 << i64toi32_i32$5 | 0) - 1 | 0) & (i64toi32_i32$3 >>> (32 - i64toi32_i32$5 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$5 | 0) | 0;
   $84 = i64toi32_i32$3 << i64toi32_i32$5 | 0;
  }
  i64toi32_i32$2 = $84;
  i64toi32_i32$0 = i64toi32_i32$1 | i64toi32_i32$0 | 0;
  i64toi32_i32$3 = i64toi32_i32$3 | i64toi32_i32$2 | 0;
  i64toi32_i32$HIGH_BITS = i64toi32_i32$0;
  return i64toi32_i32$3 | 0;
 }
```

Notice that at `XXX`, we're assigning the low part of one shift to `i64toi32_i32$3` and then, two lines down, overwriting `i64toi32_i32$3` with the high bits of one of the input arguments.

Not sure whether this is specific to bitwise operations or a more general issue.

## Comments (4)

### froydnj (2018-03-16)

Ah, `getTemp()` reuses temporary variables: https://github.com/WebAssembly/binaryen/blob/master/src/passes/I64ToI32Lowering.cpp#L1395

That doesn't seem correct, since we can't know in general whether a temporary is necessarily dead when its corresponding C++ object is destroyed.



---

### froydnj (2018-03-19)

OK, but `getTemp` actually tries to avoid that, because we can move `TempVar` values around, and the moved-from values shouldn't free the temporary variable for future use.  So in this case C++ lifetimes should provide a reasonable facsimile of lifetimes of the values in the compiled program.  But here they're not, because we're reusing a value when it's actually still live...

---

### froydnj (2018-03-19)

Ah, ok, this is actually pretty straightforward: the lowering pass is a `PostWalker` visitor, so we're visiting the leaves first.  In the original example, that's the `i64.shl` instructions.  But we don't remember that the low bits from the first `i64.shl` instruction need to remain live for the `i64.or` instruction, so the temporary that stored the low bits is reused for the second `i64.shl` instruction.  We do remember the high bits, since those are stuffed in a table for reuse and thus their `TempVar` values are not destroyed.

The straightforward solution is to remember the low bits as well, though that would require creating local vars for every such value, with corresponding `setLocal`/`getLocal` instructions, leading to somewhat cluttered IR.  The not-straightforward solution is to rewrite the lowering pass to walk the IR differently.

---

### froydnj (2018-03-19)

Another option is to run a pre-flattening pass before `i64` lowering so we never have to deal with tree structure in `wasm2asm`.  This seems to work well in testing.

---

