# #3839: Asyncify "OOM" leaves broken state

- **URL:** https://github.com/WebAssembly/binaryen/issues/3839
- **Author:** RReverser
- **Created:** 2021-04-23
- **Updated:** 2021-04-27

## Description

Right now, emitted Asyncify unwind/rewind mechanisms always stores all the variables while unwinding, and only performs bound checks in points like `asyncify_stop_unwind` when memory outside of bounds is already corrupted.

This leaves module in a broken state: even if you catch & handle the original error, calling into other exports after this point can result in all sorts of broken behaviour.

A better solution would be to perform bound checks right before storing the locals - their size is known in advance, so such condition should be fairly simple and wouldn't add any noticeable overhead, but would improve reliability a lot.

cc @kripken thoughts?

## Comments (17)

### kripken (2021-04-23)

Hmm, I had not intended the code here to be robust against an OOM... if we can make it so that sounds good, but I'm not sure we can. If an OOM happens, and we do not store locals as you suggest, where would control flow go to? To actually be correct we'd need to somehow add more memory and then resume from where we were, but I have no idea how to do that..?

Or are you imagining a more limited case where if an OOM happens the outside catches the trap and carries on, assuming the module has not been left in a broken state? (like if the code is pure and has no side effects, that would be the case I suppose)

---

### RReverser (2021-04-23)

> Or are you imagining a more limited case where if an OOM happens the outside catches the trap and carries on, assuming the module has not been left in a broken state?

Yes, essentially handling it as if there was `abort` in the original C code. You're right that for some modules this might be problematic (if they use global state), but for most worst case there will be some leaked memory, but otherwise module would still be usable.

---

### RReverser (2021-04-23)

> we'd need to somehow add more memory

This would be interesting too actually - perhaps by allowing to expose a function like `asyncify_alloc` and, when it exists, use it for allocating more... but that's a lot more complex and out of scope of this particular issue.

---

### kripken (2021-04-23)

Hmm, what's a use case you have that does *not* use global state? (not even the stack, etc.)

All the use cases I am aware of would be at very high risk of really bad corruption due to this - if they reach the pause point, they must actually pause and resume later, and not "forget" they ever tried.

---

### RReverser (2021-04-23)

Hm, perhaps you're right. I need to think about use-cases.

I should probably add that the actual issue I've encountered is that, after memory was overridden, the next calls into exports succeed without trap but return bogus values. This seems very problematic.

Even if we don't go the "allow calling further exports" route, at the very least it would be good to trap consistently once module is left in a broken state.

I haven't debugged this further, but I suspect it has something to do with ordering of `(global.set $__asyncify_state ...)` and the bound checks in some of the `asyncify_*` functions (e.g. I see that `asyncify_start_rewind` sets state first, and does bound check later which seems wrong? maybe there are more?).

---

### kripken (2021-04-26)

> I should probably add that the actual issue I've encountered is that, after memory was overridden, the next calls into exports succeed without trap but return bogus values. This seems very problematic.

Fair point. But I'm not sure Asyncify is the right place for adding a global "we trapped, abort everything from here on, flag." Some applications wouldn't need it (if they are "continuation-style", then the trap would prevent any further code from being queued to run), and others already have a mechanism for it (like emscripten). But it would make sense in a library wrapping around Asyncify, like yours, perhaps?

Maybe some of the assertions could be reordered with stores, I'm not sure offhand. But in general I feel this wouldn't be useful in general. I see the asyncify assertions as a tool for debugging during development, and then the production build should never hit them - and if you do somehow, the page could have an `onerror` handler to load an error page or something like that, as it is an unrecoverable error.

---

### RReverser (2021-04-26)

> Some applications wouldn't need it (if they are "continuation-style", then the trap would prevent any further code from being queued to run)

Hm, I'm not sure I understand / agree - if the memory is already corrupted (Asyncify wrote something out of its bounds), it seems dangerous to run any code regardless of its style since it might execute "successfully" but produce garbage values / violate even more assumptions.

> and then the production build should never hit them

In recursive algorithms you can't predict whether Asyncify will end up writing out of its bounds because it might depend on input values, which in prod can often be much more varied than in debug.

In general, I still think it's useful to move those assertions to the point before writing the values, not after the memory has already been corrupted, since it can lead to all sorts of weird bugs.

---

### kripken (2021-04-26)

Sorry, by my comment on the style I meant a style of code where nothing would run after such a trap. That is, `setInterval` is risky since if one invocation traps the next ones will still run. But if you always call `requestAnimationFrame` at the end of the current frame (like a continuation), then things halt as they should.

I agree it can be hard to guarantee the size fits in production. But recovering from an error seems quite hard if not impossible. Avoiding an error seems safer, for example, maybe the user could register a `realloc` method that is called if we run out?

---

### RReverser (2021-04-27)

> I agree it can be hard to guarantee the size fits in production. But recovering from an error seems quite hard if not impossible. Avoiding an error seems safer, for example, maybe the user could register a `realloc` method that is called if we run out?

Right, I'm ok with either solution. The way I see it, there are 3 scenarios that can happen when Asyncify doesn't have enough space:

1. Write the data out of bounds, corrupt memory, throw an error and expect caller to never call into Wasm module again because now any export can operate on garbage values.
2. Check before writing the data, don't corrupt memory, but still throw an error so caller knows that particular call didn't succeed. Next time they call into exports, those will either succeed (if invoked export doesn't use Asyncify) or naturally keep failing with the same error (if invoked export tries to use Asyncify, but space is already exhausted).
3. Check before writing the data, don't corrupt memory, but call a callback that would perform reallocation - this way, Asyncify can always succeed and execution continues successfully.

Right now, we're using scenario (1), and I'm arguing that it's the worst option of all. I agree something like (3) would be ideal, but what I'm saying is that even (2) would be simpler to implement and already a lot more helpful.

At least (2) doesn't corrupt memory and any further function calls will naturally either succeed or keep throwing errors, but they'll at least never operate on garbage data returning "successful" but wrong results.

---

### kripken (2021-04-27)

Fair summary. I do still think (2) is of very limited value, though - the program has stopped in the middle, skipping code in dangerous ways. Like this:
```cpp
{
  ClassWithRAII doRAII;
  sleep();
  // RAII destructor must be called here to release some resource
}
```
That's in addition to general global state as discussed earlier. I think very few programs could continue after a sleep ends up throwing and not continuing forward.

So I'd only be in favor of moving to (2) if it doesn't add any overhead (since if it adds none, then why not) - but I think it would? We'd need to add a check right before each unwind in each function (as opposed to just checking in the 4 API methods we add).

---

### RReverser (2021-04-27)

> I think very few programs could continue after a sleep ends up throwing and not continuing forward.

Right, this line of thinking is where I branched to "we can make all exports fail after that point" idea in my earlier comments. Although this example:

> `// RAII destructor must be called here to release some resource`

is in line with "for most worst case there will be some leaked memory, but otherwise module would still be usable" note I also made above. It's still risky, but leaking resources always seems better than outright memory corruption.

> We'd need to add a check right before each unwind in each function (as opposed to just checking in the 4 API methods we add).

This is true. That said, maybe it will compress well together with existing `asyncify_state` check since they'd be nearby and not much of an issue?

Don't get me wrong, I'd be definitely even more in favour of (3), but it just feels like a much bigger undertaking, and for now just looking for ways to avoid at least the corruption issue :)

---

### RReverser (2021-04-27)

Note that even in case of (3)

> We'd need to add a check right before each unwind in each function (as opposed to just checking in the 4 API methods we add).

this would still apply, so it seems like a necessary addition regardless of the final approach.

---

### kripken (2021-04-27)

RAII isn't just about leaked memory, though (but that is a common case). As someone that uses a lot of RAII I am terrified of the weird bugs skipping destructors could cause :smile: Again, it seems to me like (2) is safe only in very rare cases, like the complete call chain being pure code with no side effects.

Anyhow, I don't mean to re-argue the points. I'm not strongly opposed to (2) if it's done only in build with assertions enabled, for example. Would that be good enough for your use cases?

---

### RReverser (2021-04-27)

> Would that be good enough for your use cases?

Hmm, not really, because, as mentioned above, prod can still have problems since it's hard to predict required size.

Overall I agree with debug assertions being useful for nom-critical things, but memory corruption is once space where I strongly prefer extra checks over potentially operating on garbage.

Maybe I'm too used to memory-safe langs by now, but it seems like always a worthy tradeoff to lose a bit in size but avoid errors :)

I guess for now I can just add such check in my JS library and prevent calling into at least exports again. This should catch most cases (but not all, e.g. if someone got a function via Table instead).

And you said Emscripten somehow avoids this kind of memory corruption already? How? 

---

### kripken (2021-04-27)

> And you said Emscripten somehow avoids this kind of memory corruption already? How?

Emscripten avoids it basically as you said in the paragraph before last: after an error we set "ABORT", a global variable, and then we know we should not continue to run code. That includes any async callbacks scheduled for the future, which in turn includes asyncify resumes.

> Maybe I'm too used to memory-safe langs by now, but it seems like always a worthy tradeoff to lose a bit in size but avoid errors :)

This is an interesting disagreement, because that is the reason I hold my position on this topic as well... that is, the right solution is full memory safety. That is worth a cost. But here we can't achieve full safety, and the partial safety breaks on basic things like RAII, then it's better to just error/panic clearly (as we do - a trap is thrown, which signals the application to halt). Then we remain with a simple guarantee of safety.

I am open to adding an option to save a global state "we trapped", or to do a more full solution here. It is just that I am skeptical of a partial solution that doesn't handle even RAII. Basically I'm trying to avoid whack-a-mole on memory safety bugs - again, inspired by memory safe languages.

---

### RReverser (2021-04-27)

> I am open to adding an option to save a global state "we trapped"

Oh right, so you're not opposed to adding "we trapped" mode and preventing further calls? I probably misunderstood your earlier comments, but then, we talked about several options at once, so some confusion was inevitable.

Yeah, if we could go down that route, that works too.

---

### kripken (2021-04-27)

Sorry if I wasn't clear earlier. Also I may have shifted my opinions slightly over the discussion :smile: 

But yeah, I think as an optional thing that sounds fine.

---

