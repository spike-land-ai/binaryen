# #1562: wasm2asm: Needs support for exported tables

- **URL:** https://github.com/WebAssembly/binaryen/issues/1562
- **Author:** alexcrichton
- **Created:** 2018-05-22
- **Updated:** 2018-06-02

## Description

Right now if a table is exported from a wasm module no bindings for that are generated with `wasm2asm`, meaning that code which otherwise expects the wasm table to be there (to invoke wasm functions dynamically) won't work.

I think this'll probably want similar treatment to exporting memory where a shim object is injected with a wasm-table-like API to get the bare bones working.

cc @fitzgen

## Comments (2)

### caspervonb (2018-05-30)

Previously mentioned in https://github.com/WebAssembly/binaryen/issues/1256

---

### caspervonb (2018-06-01)

In the meantime I've had to hack my way around this with a fairly gnarly shell script, basically wasm2asm generates code per normal then I add another layer "wasm compatible" around it.

```js
function wasm(imports) {
  var memory = {
    buffer: new ArrayBuffer(64 * 1024),
  };

  var exports = asm(self, imports.env, memory.buffer);
  var indirect_function_table = {
    elements: [
      exports['tock'],
      exports['tick'],
    ],

    get: function(index) {
      var entry = this.elements[index - 1];
      if (entry == null) {
        throw new RuntimeError("invalid table entry at " + index);
      }

      return entry;
    },
  };

  function asm(global, env, buffer) {
    "use asm";

    // ...
    var callback = env.callback;

    function __wasm_call_ctors() {
    }

    function tock() {
      // ...
    }

    function tick() {
      //
    }

    function main() {
      callback(1 | 0) | 0;
      callback(2 | 0) | 0;
    }

    return {
      __wasm_call_ctors: __wasm_call_ctors,
      tock: tock,
      tick: tick,
      main: main,
    };
  }

  return {
    exports: {
      main: exports.main,
      __memory: memory,
      __indirect_function_table: indirect_function_table,
    },
  }
}
```

The obvious pitfall to my approach however is that my "loose" function table is only gettable, but I've never actually had use case yet for a settable function table.

Doing it this way seems more doable than interfacing Asm.js internal function tables.

---

