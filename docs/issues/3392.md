# #3392: CSE doesn't work for subexpressions with implicit trap

- **URL:** https://github.com/WebAssembly/binaryen/issues/3392
- **Author:** MaxGraey
- **Created:** 2020-11-20
- **Updated:** 2020-11-22

## Description

I have very simple example:
```wat
(func $test (export "test") (type $t0) (param $p0 i32) (param $p1 i32) (result i32)
    local.get $p0
    local.get $p1
    i32.rem_u
    i32.eqz
    local.get $p0
    local.get $p1
    i32.rem_u
    i32.const 1
    i32.eq
    i32.or)
```
and expect this:
```wat
(func $test (export "test") (type $t0) (param $p0 i32) (param $p1 i32) (result i32)
    local.get $p0
    local.get $p1
    i32.rem_u
    local.tee $p0
    i32.eqz
    local.get $p0
    i32.const 1
    i32.eq
    i32.or)
```
But unfortunately CSE didn't apply. Thoughts?

Upd: It seems this happened due to side effect. Because `x % 10` properly eliminated

## Comments (4)

### MaxGraey (2020-11-20)

I guess if matched subexpressions contains in the same basic block they are could eliminated even with implicit traps. Or I miss something?

---

### tlively (2020-11-20)

In general, we could apply CSE to any implicitly-trapping expressions for which we can prove that the expression will not trap unless all of the common expressions that can reach it (in the control flow sense) would trap. That gets tricky when there are locals involved, though. Here's an example where it would be invalid to apply CSE:

```
(func (param i32 i32 i32)
  (drop
    (i32.rem_u
      (local.get 0)
      (local.get 1)
    )
  )
  (call $side_effect)
  (local.set 1
    (local.get 2)
  )
  (drop
    (i32.rem_u
      (local.get 0)
      (local.get 1)
    )
  )
)
```

In this case, CSE of the remainder expressions would be observable if the third parameter to the function were 0.

---

### MaxGraey (2020-11-21)

Also need to be accurate with globals:
```wat
(func (param i32)
  (drop
    (i32.rem_u
      (local.get 0)
      (global.get $g0)
    )
  )
  (call $side_effect) ;; which modify $g0 global
  (drop
    (i32.rem_u
      (local.get 0)
      (global.get $g0)
    )
  )
)
``` 

---

### kripken (2020-11-22)

I'm not sure, but I think the current effect tracking in the pass should be able to handle things like that. It will invalidate when it crosses a side effect it is not allowed to cross.

But more generally, to "merge" two copies of the same subexpression we need to know that we don't need to run the side effect twice. It's not ok to merge two calls to an import, for example. It may also not be ok to merge two writes to a local, unless the value is identical, etc. A possible trap could be merged, though, so the pass could probably be extended to allow that specifically.

---

