# #4274: Redundant global read

- **URL:** https://github.com/WebAssembly/binaryen/issues/4274
- **Author:** MaxGraey
- **Created:** 2021-10-24
- **Updated:** 2021-10-25

## Description

In situations when global reads immediately after write we could avoid this read and use argument of global.set. For example this:
```wat
(module
  (global $g (mut i32) (i32.const 0))
  (func $test (param $0 i32) (result i32)
    (global.set $g (local.get $0))
    (global.get $g)
  )
)
```
can be optimized as:
```wat
(module
  (global $g (mut i32) (i32.const 0))
  (func $test (param $0 i32) (result i32)
    (global.set $g (local.get $0))
    (local.get $0)
  )
)
```
if arg is simple like `local.get` or `i32.const`
and something like this if arg more complex:
```wat
(module
  (global $g (mut i32) (i32.const 0))
  (func $test (param $0 i32) (result i32)
    (global.set $g (local.tee $tmp (...complex expr...)))
    (local.get $tmp)
  )
)
```

## Comments (5)

### kripken (2021-10-25)

This is one of the things that #3858 is meant to help with. So far it has been low priority due to little information on how beneficial it would be, and it is quite complex.

---

### MaxGraey (2021-10-25)

Well in AS codegen it's quite often situation. Could you check this pattern for j2cl?

---

### kripken (2021-10-25)

I haven't seen it often in j2wasm. The main use of globals there is of immutable globals, which binaryen can now optimize pretty well.

I think it would be good to solve, though, regardless. Perhaps someone can think of a simpler algorithm specifically for this, instead of general dead store elimination + forwarding. One thing that might help is the dominator tree logic that has been added since that PR was open, and which might make this easier.

---

### MaxGraey (2021-10-25)

I think this task is very similar to the RSE pass, only relate to globals and not for writing but for reading. Dead Store Elimination is a bit different, or am I missing something?

---

### kripken (2021-10-25)

It is similar to both, yes.

The connection to dead store elimination is that once you have the infrastructure to identify which stores trample which other stores (which requires understanding global state, and that some calls can modify it, etc.), then you can fairly easily extend that to forwarding stored values to loads. That is, once you know which stores are live at each position, you can use that to either remove another store, or forward a loaded value.

The connection to redundant store elimination is that it does something similar to dead store elimination, but on locals, and only on repeated identical values. Note that coalesce-locals does a more general dead store elimination on locals; redundant store elimination is run much later in the pipeline and is meant to handle some simple cases quickly without doing another full run of coalesce-locals.

---

