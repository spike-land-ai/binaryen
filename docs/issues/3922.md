# #3922: Do not pop from the polymorphic stack (was: Parse expection on unreachable struct.set)

- **URL:** https://github.com/WebAssembly/binaryen/issues/3922
- **Author:** askeksa-google
- **Created:** 2021-06-07
- **Updated:** 2021-06-08

## Description

When processing [this module](https://github.com/WebAssembly/binaryen/files/6608089/stubbed.wasm.gz) using https://github.com/WebAssembly/binaryen/commit/a4ab1c7ee7376977ca09e2d3c4358893e9fdfce2, I get the following error:
```
[parse exception: bad heap type: expected (struct (field (mut (ref null (struct (field (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32))))))))) (mut (ref null (struct (field (mut i32) (mut i32) (mut i64) (mut (ref null (struct (field (mut i32) (mut i32))))))))) (mut (ref null (struct (field (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32) (mut ...1) (mut i64) (mut (ref null (struct (field (mut i32))))) (mut (ref null (struct (field (mut i32) (mut i64))))) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32))))) (mut (ref null (struct (field (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32) (mut dataref) (ref (func (param dataref) (result (ref null (struct (field (mut i32))))))))))) (mut (ref null (struct (field (mut i32) (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32))))))))) (mut (ref null (struct (field (mut i32) (mut i32))))) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32))))) (mut (ref null (struct (field (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32) (mut i64) (mut i64) (mut (ref null (struct (field (mut i32) (mut i32) (mut ...3) (mut ...1) (mut ...1))))))))) (mut (ref null (struct (field (mut i32) (mut i32) (mut i64) (mut (ref null (struct (field (mut i32) (mut i32))))))))) (mut (ref null (struct (field (mut i32) (mut i32) (mut i64) (mut (ref null (struct (field (mut i32) (mut i32))))))))) (mut (ref null (struct (field (mut i32) (mut i32))))) (mut (ref null (struct (field (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32))))))))) (mut (ref null (struct (field (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32) (mut i64) (mut i64) (mut (ref null (struct (field (mut i32) (mut i32) (mut ...3) (mut ...1) (mut ...1))))))))) (mut i32) (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32))))) (mut (ref null (struct (field (mut i32) (mut i32) (mut dataref) (ref (func (param dataref (ref null (struct (field (mut i32)))) (ref null (struct (field (mut i32))))) (result (ref null (struct (field (mut i32))))))))))) (mut ...3) (mut (ref null (struct (field (mut i32) (mut i32))))) (mut (ref null (struct (field (mut i32) (mut i32))))) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32) (mut i64) (mut i64) (mut (ref null (struct (field (mut i32) (mut i32) (mut ...3) (mut ...1) (mut ...1))))))))) (mut i32) (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32))))) (mut (ref null (struct (field (mut i32) (mut i32) (mut dataref) ..!)))) (mut ..!) (mut ..!) (mut ..!) (mut i32) (mut ..!) (mut ..!) (mut ..!) (mut ..!) (mut i32))))) (mut ..!) (mut ..!) (mut ..!) (mut i32) (mut ..!))))) (mut ..!) (mut ..!) (mut ..!) (mut i32))))) (mut i64) (mut i32) (mut ..!) (mut ..!))))) (mut ..!) (mut ..!) (mut ..!) (mut ..!) (mut i32) (mut i32) (mut i32) (mut i32) (mut i32))))) (mut i64) (mut ..!) (mut ..!) (mut i32) (mut ..!) (mut ..!) (mut ..!) (mut ..!) (mut ..!) (mut ..!) (mut i32) (mut i32) (mut i32) (mut i32) (mut i32) (mut ..!) (mut i32) (mut ..!) (mut i32))))) (mut ..!) (mut ..!) (mut ..!) (mut ..!) (mut i32) (mut i32) (mut ..!) (mut ..!) (mut ..!) (mut ..!) (mut ..!) (mut ..!) (mut ..!) (mut ..!) (mut ..!) (mut i32) (mut ..!) (mut i32) (mut ..!) (mut ..!) (mut ..!) (mut i32) (mut ..!) (mut i32) (mut i32) (mut ..!))))) (mut ..!) (mut ..!) (mut ..!) (mut i32) (mut ..!) (mut ..!) (mut ..!) (mut i32))) but found (ref (struct (field (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32)))))))) (at 0:259577)]
Fatal: error parsing wasm
```
The offending instruction sequence is:
```wat
(unreachable)
(global.get 43)
(ref.cast)
(struct.set $context 5)
```
Due to the `unreachable`, this sequence should be valid in all contexts, since it is valid if it would be valid for any stack contents. V8 accepts the code.

I tried to construct a smaller example, but my simpler cases did not trigger the error. I stubbed all other functions in the module to cut down on the size a bit.

By the way, how come this is a parse error, rather than a validation error? It could be useful to be able to disable such checks using `--no-validation`.

## Comments (6)

### kripken (2021-06-07)

The reason this is a parse error is that Binaryen cannot represent it in IR. The IR is more compact than wasm in some ways. It does have the downside of not being able to ignore validation, that is true...

I am not 100% sure what is going on here. We don't actually pop anything from the unreachable/polymorphic stack that affects the validation of that instruction. That is, the reference we are doing a struct.set on is that `(ref.cast (global.get ..))`. That the value (the other child of the instruction) we are assigning is unreachable seems separate - unless there is a general rule in wasm validation that I am unaware of, that if even a single child is from the polymorphic stack, we must ignore all validation? (In general I think our principle is to validate as much as possible in such cases.)

The error looks like a real one to me: `$context` and the heap type of that `ref.cast` are not compatible:
```
(struct (field (mut i32) ...
vs
(struct (field (mut (ref null ...
```

---

### askeksa-google (2021-06-08)

The value produced by the `ref.cast` flows into the second input to the `struct.set`, i.e. the stored value, not the reference. Thus, the check should be whether the type of the `ref.cast` result is compatible with the type of field 5 of `$context`. Those have the same type here (a struct with an `i32` and an `f64`).

---

### kripken (2021-06-08)

I think maybe we are looking at different things, hmm...

To investigate this, I added diffs like this:
```diff
diff --git a/src/wasm/wasm-binary.cpp b/src/wasm/wasm-binary.cpp
index 5dad26113..8d240134d 100644
--- a/src/wasm/wasm-binary.cpp
+++ b/src/wasm/wasm-binary.cpp
@@ -6453,12 +6453,16 @@ bool WasmBinaryBuilder::maybeVisitStructSet(Expression*& out, uint32_t code) {
   if (code != BinaryConsts::StructSet) {
     return false;
   }
+  std::cout << "build StructSet at " << pos << "\n";
   auto* curr = allocator.alloc<StructSet>();
   auto heapType = getIndexedHeapType();
   curr->index = getU32LEB();
   curr->value = popNonVoidExpression();
   curr->ref = popNonVoidExpression();
+  std::cout << "--value is " << getExpressionName(curr->value) << "\n";
+  std::cout << "--ref   is " << getExpressionName(curr->ref) << "\n";
   validateHeapTypeUsingChild(curr->ref, heapType);
+  std::cout << "--valid.\n";
   curr->finalize();
   out = curr;
   return true;
```
which reports
```
build StructSet at 259574
--value is RefCast
--ref   is RefCast
[parse exception: bad heap type: expected (struct (field (mut (ref null (struct ...
 but found (ref (struct (field (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32)))))))) (at 0:259577)]
```
The binary looks like this:
```
0003f5e0  23 e7 05  fb 41   fb 03 90  03 02 d3 23 05 fb 41       00  |#...A......#..A.|
                                                        ||       ||
                                                        RefCast  Unreachable

0003f5f0  23 2b fb  41 fb   06 89 1e  05 20 02 fb 03 8f 03 0b  |#+.A..... ......|
          ||        ||      ||
          GlobalGet RefCast ||
                            ||
                            StructSet
```
So there are *two* RefCasts there. Both of the inputs to the StructSet are RefCasts, and the ref one appears to have an incompatible heap type. Specifically, the last of the RefCasts, the value, has an unreachable as its value. But the previous RefCast, the ref, has reachable inputs, and it has type `(ref (struct (field (mut i32) (mut i32) (mut (ref null (struct (field (mut i32) (mut i32))))))))`. But that type is not compatible with the StructSet's type, which starts with `(struct (field (mut (ref null (struct `. So this looks like invalid wasm to me.

---

### askeksa-google (2021-06-08)

The [validation rule](https://webassembly.github.io/multi-memory/core/valid/instructions.html#valid-unreachable) for `unreachable` states that it is valid for *any* sequences of input and output types. Thus, if there exist any `[t1*]` and `[t2*]` such that the instructions before it deliver `[t1*]` and the instruction afterwards consume `[t2*]`, the code is valid.

In other words, `unreachable` acts as a "barrier" which makes the validation of instructions after it independent of the instructions before it.

For the case at hand, the first input to the `struct.set` is not the first `ref.cast`; rather, it's an element of the polymorphic stack left by the `unreachable`.

A corollary of this validation rule which I think is one of the motivations for formulating it this way, and which I have found to give a good intuition about it, is:

*If you take a valid program and replace any balanced sequence of instructions by `unreachable`, the program is still valid*.

For a code generator, this means that any language construct which for some reason can't be translated (e.g. because it is not implemented yet) can just be emitted as `unreachable` without worrying about what it was supposed to be consuming and producing on the value stack. I've been doing that a lot in `dart2wasm`. In this particular case, a method call was determined (by a TFA) to have no possible targets, meaning the call is dynamically unreachable, and was therefore emitted as `unreachable` instead of the actual call.

---

### kripken (2021-06-08)

Ah yes, I think you're right...

Looking into this, it likely requires a large refactoring of binaryen's binary reading code. Is this urgent for you / blocking something?

---

### askeksa-google (2021-06-08)

It was blocking me from optimizing the output from `dart2wasm` with Binaryen for my target benchmark, but I found a workaround: wrap the `unreachable` in a block with output types corresponding to the stack contents expected by subsequent instructions. So fixing this particular issue is not urgent.

I ran into some other issues next, described in https://github.com/WebAssembly/binaryen/issues/3926.



---

