# #2458: LIFO order optimization?

- **URL:** https://github.com/WebAssembly/binaryen/issues/2458
- **Author:** MaxGraey
- **Created:** 2019-11-20
- **Updated:** 2019-11-20

## Description

Not sure about this, but I find out code like this:
```ts
...
let lo = (code >>> 10) | 0xD800;
let hi = (code & 0x03FF) | 0xDC00;
u32.store(codes + (j << 1), lo | (hi << 16));
...
```
produce smaller (less get/set for locals) output than
```ts
...
let lo = (code >>> 10) | 0xD800;
let hi = (code & 0x03FF) | 0xDC00;
u32.store(codes + (j << 1), (hi << 16) | lo);
...
```
It seems will be great have pass which could reorder local  assignments (hi, lo) or reorder arguments in expressions if this possible in LIFO style

Unfortunately I can't reproduce this in small example it seems we should have some extra factors so link to [before/after diff](https://github.com/AssemblyScript/assemblyscript/pull/965/commits/e647bc6b13038db25a419fe3cd2abc5e7c28c455#diff-0ec1e6fe4a572f7b9ac7e342ca12603b)

## Comments (1)

### kripken (2019-11-20)

The diff is pretty hard to read for me, so not sure what's going on, but as the source change is a flip of `X|Y` to `Y|X`, it might be that it can avoid using a local and just use the stack, when the order is friendlier.

If someone wants to look at that, the StackIR pass is `local2Stack`, https://github.com/WebAssembly/binaryen/blob/master/src/passes/StackIR.cpp#L97

Currently that just looks for cases where a local is set, then later there is a get, and the value could have just been on the stack instead (remove the set and get, and it's still valid). It doesn't look for flipping opportunities of binary instructions.

---

