# #1764: List of missing peephole optimizations

- **URL:** https://github.com/WebAssembly/binaryen/issues/1764
- **Author:** MaxGraey
- **Created:** 2018-11-24
- **Updated:** 2023-02-18

## Description

Is it possible doing some trivial logical simplifications for now? Or better wait souper with z3 solver for that?
like simplify from:
```wat
(func $test (export "test") (type $t0) (param $p0 i32) (result i32)
    get_local $p0
    i32.const 10
    i32.gt_s
    get_local $p0
    i32.const 10
    i32.eq
    i32.or)
```
to:
```wat
(func $test (export "test") (type $t0) (param $p0 i32) (result i32)
    get_local $p0
    i32.const 9
    i32.gt_s)
```
or:
```wat
(func $test (export "test") (type $t0) (param $p0 i32) (result i32)
    get_local $p0
    i32.const 10
    i32.ge_s)
```


**DONE:**
from:
```wat
  get_global $i
  i32.const 0
  i32.le_s
  i32.eqz
  if
```
to:
```wat
  get_global $i
  i32.const 0
  i32.gt_s
  if
```

## Comments (62)

### kripken (2018-11-24)

Good idea, we should do these!

It's not hard to add them. The correct pass is OptimizeInstructions (`src/passes/OptimizeInstructions.cpp`). Do you want to do it?

---

### MaxGraey (2018-11-24)

Oh, great! I think better if you start some basics and may be after I add additional methods/rules for that pass =)

---

### kripken (2018-11-24)

@MaxGraey Sounds good, I can get the stuff set up so that it's just a matter of adding the specific rules into that pattern. Take a look at https://github.com/WebAssembly/binaryen/commit/d3e5d4416f1bcb8fe3998db39351be766ba250aa - I added the first rule into `combineOr` there, and a test in `$combine-or`. The rest should be straightforward, let me know if you need any help.

(I realized I need to land a few other things before that commit, so I can't land it right now, but posting this now so you can get started if you want.)

---

### MaxGraey (2018-11-25)

Great! Are you plan merge this to master? Or I can just fork `oi2` and continue work in separate branch?

btw I use one trick with range checking if all arguments is unsigned. Like:
```c
(x >= C0) & (x <= C1)
```
where `x`, `C0` and `C1` are unsigned ints
```c
(unsigned)x - C0 <= C1 - C0
```

Also integer sequence of logical expressions like:
```c
(x == C) | (x == C + 1) | ... | (x == N)
```
could transform to:
```c
(unsigned)(x - C) <= N - C
```

is it make sense implement this rule as well, wdyt?

---

### kripken (2018-11-25)

@MaxGraey 

Yes, for now fork `oi2` and work on that, since I might not be able to land it today.

That unsigned trick looks valid to me. Maybe leave it for a separate PR afterwards though, so there isn't too much in one?

---

### MaxGraey (2018-11-27)

Also figure outing some useful rules for integer (sing/unsign) comparators:
```
x > x - 1
```
could always transform to:
```
x != MIN_VALUE
```
and
```
x + 1 > x
```
could always transform to:
```
x != MAX_VALUE
```

---

### MaxGraey (2018-11-27)

Also wdyt using for `x != 0`:
```wat
get_local $0
i32.eqz
i32.eqz
```
instead
```wat
get_local $0
i32.const 0
i32.ne
```
This reducing code by 1 byte, but generate worse machine code so this probably useful only for shrink code >= 2. Of course this not very likely code because `if/else/select` don't require this operation explicitly

---

### kripken (2018-11-28)

Comment before last looks good to me.

Last comment also looks good - as you said in if or select etc. inputs we can flip the arms and avoid != 0 anyhow, but there are cases when it happens elsewhere, so i think it's a good rule to add.

---

### kripken (2018-12-20)

@MaxGraey how are you getting along with these optimizations? Anything I can help with?

---

### MaxGraey (2018-12-20)

@kripken Sorry, currently I busy on work but I hope I will return to this on weekend

---

### MaxGraey (2019-01-30)

Just note. Found another possible improvments like transform this:
```wat
i32.const 1
i32.const 0
get_local $p0
select
```
or this:
```wat
get_local $p0
if $I0 (result i32)
  i32.const 1
else
  i32.const 0
end
```
to this (depending on `$p0` type)
```wat
get_local $p0
i32.const 0
i32.ne
```

UPDATE
----
Implemented in #2869

---

### MaxGraey (2019-03-10)

More possible optimizations:
1. from:
```wat
(func $t1 (export "t1") (type $t0) (param $p0 i32) (result i32)
    get_local $p0
    i32.const 0
    i32.lt_s)
```
to:
```wat
(func $t1 (export "t1") (type $t0) (param $p0 i32) (result i32)
    get_local $p0
    i32.const 31
    i32.shr_s)
```
2. from:
```wat
 (func $t2 (export "t2") (type $t0) (param $p0 i32) (result i32)
    get_local $p0
    i32.const -1
    i32.ne)
```
to (but not always possible, probably valid only if result used as `i1` in next steps):
```wat
(func $t2 (export "t2") (type $t0) (param $p0 i32) (result i32)
    get_local $p0
    i32.const -1
    i32.xor)
```

---

### MaxGraey (2020-04-25)

one more peephole optimization:

`~(1 << n)` -> `rotl(-2, n)`

which looks like in wat as:
```wat
    i32.const 1
    get_local $p0
    i32.shl
    i32.const -1
    i32.xor
```
to:
```wat
    i32.const -2
    get_local $p0
    i32.rotl
```

Done!

---

### MaxGraey (2020-05-24)

`(x >> C) != 0`   =========>   `(unsigned)x > ((1 << C) - 1)`
`((unsigned)x >> C) > 0`   ==>   `(unsigned)x > ((1 << C) - 1)`
`((signed)x >> C) > 0`   ====>   `(signed)x > ((1 << C) - 1)`

`(x >> C) == 0`   =========>   `(unsigned)x < ((1 << C) - 1)`
`(x >> C) < 0`   ==========>   `(unsigned)x < ((1 << C) - 1)`
`((signed)x >> C) < 0`  ====>  `(unsigned)x >> 31`
~~`((unsigned)x >> C) < 0`  ==>  `0`~~

---

### MaxGraey (2020-05-24)

Such distributive optimizations for integers also missing currently:
```
x * y + x * z
x * y - x * z
```
to
```
x * (y + z)
x * (y - z)
```

**Upd** PR: #3132

---

### MaxGraey (2020-05-27)

~~`(signed)x % С_pot == 0` ==> `(x & (С_pot - 1)) == 0`~~
~~`(signed)x % С_pot != 0` ==> `(x & (С_pot - 1)) != 0`~~
`x % C == C` ==> `0`
`x % C != C` ==> `1`, if `C != 0`

`(unsigned)x % C >= C`, 
`(unsigned)x % C > C` ==> `0`, if `C != 0`

`(signed)x % C >= C`, 
`(signed)x % C > C` ==> `C < 0`, if `C != 0`

`(unsigned)x % C <= C`, 
`(unsigned)x % C < C` ==> `1`, if `C != 0`

`(signed)x % C <= C`, 
`(signed)x % C < C` ==> `(C ^ -1) < 0`, if `C != 0`

---

### MaxGraey (2020-06-16)

Pretty common patterns. But what is surprising is neither LLVM nor GCC can't optimize this:
`(x > y) - (x < y) < 0` -> `x < y`
`(x > y) - (x < y) <= 0` -> `x <= y`
`(x > y) - (x < y) == 0` -> `x == y`
`(x > y) - (x < y) > 0` -> `x > y`
`(x > y) - (x < y) >= 0` -> `x >= y`

Need to think could we generalize this more

---

### MaxGraey (2020-06-16)

// add-sub integer patters
`(x + y) - x` -> `y`
`(x - y) - x` -> `0 - y`
`(x + y) - y` -> `x`
`(x - y) - y` -> `x - (y << 1)`

`x - (x + y)` -> `0 - y`
~~`x - (x - y)` -> `y`~~ (#3014)
`y - (x + y)` -> `0 - x`
`y - (x - y)` -> `(y << 1) - x`

`(x + y) + x` -> `(x << 1) + y`
`(x - y) + x` -> `(x << 1) - y`
`(x + y) + y` -> `(y << 1) + x`
`(x - y) + y` -> `x`

however probably better add general Reassociate sub pass which also handle others associative ops like |, &, ^

// div-mul integer patters
`((signed)x / y) * y` -> `x - ((signed)x % y)`
`((unsigned)x / y) * y` -> `x - ((unsigned)x % y)`, if pure(x) && pure(y) && y != C



---

### MaxGraey (2020-06-21)

~~`-(x + C)` -> `-C - x`~~
~~`-(C - x)` -> `x - C`~~
`-1 - x` -> `x ^ -1`

---

### MaxGraey (2020-07-02)

`bool(x) ? -1 : 0` -> `0 - x`
`bool(x) ? 0 : -1` -> `0 - (x ^ 1)`

where `bool(x) ` is  `getBits(x) == 1`

---

### MaxGraey (2020-08-01)

float point simplifications:

`x  > 0.0 ? 1.0 : -1.0` -> `copysign(1.0, +x)`
`x >= 0.0 ? 1.0 : -1.0` -> `copysign(1.0, +x)`
`x   < 0.0 ? 1.0 : -1.0` -> `copysign(1.0, -x)`
`x <= 0.0 ? 1.0 : -1.0` -> `copysign(1.0, -x)`

`x  > 0.0 ? -1.0 : 1.0` -> `copysign(1.0, -x)`
`x >= 0.0 ? -1.0 : 1.0` -> `copysign(1.0, -x)`
`x  < 0.0 ? -1.0 : 1.0` -> `copysign(1.0, +x)`
`x <= 0.0 ? -1.0 : 1.0` -> `copysign(1.0, +x)`

`copysign(x, +C)` -> `abs(x)`
`copysign(x, -C)` -> `-abs(x)`

`x * copysign(1.0, x)` -> `abs(x)`
`x * copysign(1.0, -x)` -> `-abs(x)`
~~`abs(x) * abs(x)` -> `x * x`~~ (#3013)

`copysign(x, y) == 0` -> `x == 0`

`copysign(copysign(x, y), z)` -> `copysign(x, z)`
`copysign(x, y) * copysign(x, y)` -> `x * x`

~~`sqrt(x) < C` -> `x >= 0 && x < C * C`~~

---

### MaxGraey (2020-08-02)

`x / C_pot` -> `x * (1 / C_pot)` (#3018)

where `x` -> float point, `C_pot` power of two float point constant

---

### MaxGraey (2020-08-02)

~~`x * 2.0` -> `x + x`~~ (#3016) done!

It seems this transform may reduce up to 7 bytes due to wasm doesn't use any variant encoding for floats
cc @kripken 

---

### MaxGraey (2020-08-15)

~~`i32(i64(x))`  ->  `x`,  where x::i32~~ done
~~`i32(u64(x))`  ->  `x`,  where x::i32~~ done
same as:
```wat
i64.extend_s/i32 ;; or i64.extend_u/i32
i32.wrap/i64
```

~~`i64(u32(x))`  -> `x & 0xFFFFFFFF`, where x::i64~~ not optimal
~~or~~
~~i32.wrap/i64
i64.extend_u/i32 ;; but not for extend_s/i32~~


---

### MaxGraey (2020-08-29)

`x ? 0 : C_pot` -> `(!x) << log2(C_pot)`
`x ? C_pot : 0` -> `(!!x) << log2(C_pot)`

`x * (y ? C1 : C2)` -> `y ? C1 * x : C2 * x`, if  `C1, C2` <- `-1 | 0 | 1`

examples:

  `x * (y ? -1 : 1)` -> `y ? -x : x`
  `x * (y ? 1 : 0)` -> `y ? x : 0`
  `x * (y ? -1 : 0)` -> `y ? -x : 0`

---

### MaxGraey (2020-10-02)

`~x | x` -> `-1`
~~`~x ^ x` -> `-1`~~
`~x + x` -> `-1`
`~x + 1` -> `0 - x`

~~`-x - 1` -> `~x` (x ^ -1)~~
`-1 - x` -> `~x` (x ^ -1)

---

### MaxGraey (2021-03-05)

~~`x < 0 ? -1 : 1`  ->  `x >> 31 | 1`~~ done!

---

### MaxGraey (2021-09-12)

`x / C`  ->  `0`  if `maxBits(x) < maxBits(C)`

like:
`(x & 3) / 4` -> `0`

---

### MaxGraey (2021-09-16)

`i32(f64.max(f64(x), f64(y)) -> select(x, y, x > y)`, if `type(x & y) == i32 | u32`
`i32(f64.min(f64(x), f64(y)) -> select(x, y, x < y)`, if `type(x & y) == i32 | u32`

`i32(f64.abs(f64(x))) -> select(-x, x, x < 0)`, if `type(x) == i32`

**DONE**

~~`i32(f64(x)) -> x`,  if `type(x) == i32 | u32`~~
~~`u32(f64(x)) -> x`,  if `type(x) == i32 | u32`~~

~~`floor(f64(x)) -> f64(x)`, if `type(x) == i32 | u32`~~
~~`ceil(f64(x)) -> f64(x)`, if `type(x) == i32 | u32`~~
~~`trunc(f64(x)) -> f64(x)`, if `type(x) == i32 | u32`~~
~~`nearest(f64(x)) -> f64(x)`, if `type(x) == i32 | u32`~~


---

### MaxGraey (2021-09-24)

`-(i32(x) / C)`  ->  `i32(x) / -C`, if `x != u32`, `C != min_s`

this can't be optimized nor div_s either div_u:
~~-x / C  ->  x / -C~~


---

### MaxGraey (2021-10-21)

~~`(x < 0) | (y < 0)` -> `(x | y) < 0`~~
~~`(x < 0) & (y < 0)` -> `(x & y) < 0`~~

---

### MaxGraey (2021-10-21)

```rust
(x & z) | (y & z)   ->   (x | y) & z 
(x & z) & (y & z)   ->   (x & y) & z
(x & z) ^ (y & z)   ->   (x ^ y) & z

(x | z) & (y | z)   ->   (x & y) | z
(x | z) | (y | z)   ->   (x | y) | z
(x | z) ^ (y | z)   ->   (x ^ y) | z

(x ^ z) & (y ^ z)   ->   skip
(x ^ z) | (y ^ z)   ->   skip
(x ^ z) ^ (y ^ z)   ->   x ^ y
```

---

### MaxGraey (2021-10-23)

```rust
(x | C1) ^ (x & C2)   ->   (x & C3) ^ C1, where C3 = ~C1 ^ C2
(x | C1) ^ (x | C2)   ->   (x & C3) ^ C3, where C3 =  C1 ^ C2
(x & C1) ^ (x & C2)   ->   (x & C3),      where C3 =  C1 ^ C2
```

---

### MaxGraey (2021-10-23)

```rust
(x ^ y) != 0    ->    x != y
(x ^ y) == 0    ->    x == y
```

---

### MaxGraey (2021-10-23)

```rust
x ? y + z : y + w  ->  y + (x ? z : w)
x ? y - z : y - w  ->  y - (x ? z : w)
x ? y * z : y * w  ->  y * (x ? z : w)
x ? y / z : y / w  ->  y / (x ? z : w)
x ? y % z : y % w  ->  y % (x ? z : w)
x ? y | z : y | w  ->  y | (x ? z : w)
x ? y & z : y & w  ->  y & (x ? z : w)
x ? y ^ z : y ^ w  ->  y ^ (x ? z : w)
```
```rust
x ? y | z : z  ->  z | (x ? y : 0)
x ? z : y | z  ->  z | (x ? 0 : y)
x ? y ^ z : z  ->  z ^ (x ? y : 0)
x ? z : y ^ z  ->  z ^ (x ? 0 : y)
x ? y & z : z  ->  z & (x ? y : -1)
x ? z : y & z  ->  z & (x ? -1 : y)
x ? y + z : z  ->  z + (x ? y : 0)
x ? z : y + z  ->  z + (x ? 0 : y)
x ? y - z : z  ->  (x ? y : 0) - z
x ? z : y - z  ->  (x ? 0 : y) - z
x ? z - y : z  ->  z - (x ? y : 0)
x ? z : z - y  ->  z - (x ? 0 : y)
x ? y * z : z  ->  z * (x ? y : 1)
x ? z : y * z  ->  z * (x ? 1 : y)
```

---

### MaxGraey (2021-10-24)

normalize:
`(x + (-C1)) & C2`  ->   `(x + (C1 & ~C2)) & C2`

`(x + C1) & C2`  ->  `x & C2`,   if `(((C1 - 1) & C2) == 0 && (C1 & (C1 - 1)) == 0`

---

### MaxGraey (2021-10-27)

`eqz((signed)x >> C)`  ->  `(unsigned)x < (1 << C)`
`eqz((unsigned)x >> C)`  ->  `(unsigned)x < (1 << C)`

limit `C <= 12` for `shrinkLevel != 0` 

---

### MaxGraey (2021-10-29)

 `i64.extend_i32_s(i32.extend8_s(i32.wrap_i64(i64(x))))` -> `i64.extend8_s(x)`
 `i64.extend_i32_s(i32.extend16_s(i32.wrap_i64(i64(x))))` -> `i64.extend16_s(x)`

---

### MaxGraey (2021-10-30)

`(x & C1) <<>> C2` -> `(x <<>> C2) & C1'`, 
`(x | C1) <<>> C2` -> `(x <<>> C2) | C1'`,
`(x ^ C1) <<>> C2` -> `(x <<>> C2) ^ C1'`,
`(x + C1) <<>> C2` -> `(x <<>> C2) + C1'`,
  where `C1' = C1 <<>> C2`, `<<>>` is any shift op (`<<`, `>>`, `>>>`)

---

### MaxGraey (2021-11-12)

`x ? 1 << y : 0` -> `(x != 0) << y`

btw this doesn't apply by LLVM yet

---

### MaxGraey (2021-11-15)

`(x ^ y) | (x ^ -1)`  ->  `(x & y) ^ -1`

---

### MaxGraey (2021-11-18)

`(x << z) op (y << z)`  ->  `(x op y) << z`, where `op` is `|`, `&`, `^`, `+`, `-`

`(x >> z) op (y >> z)`  ->  `(x op y) >> z`
`(x >>> z) op (y >>> z)`  ->  `(x op y) >>> z`, where `op` is `|`, `&`, `^`

---

### MaxGraey (2021-11-18)

```rust
(i64(x) >> C1) & C2   ->   u64(x) >>> C1
(u64(x) >> C1) & C2   ->   u64(x) >>> C1
```
where 
`C1 >= 32`,
`C2 <- (C2 & u64(0xFFFFFFFF)) == u64(0xFFFFFFFF)`

---

### MaxGraey (2021-12-04)

```rust
// isNaN(x) ? 0 : int(x)
x != x ?  0 : trunc_sat_(f64|f32)_(s|u)(x)    ->   trunc_sat_(f64|f32)_(s|u)(x)
// !isNaN(x) ? int(x) : 0
x == x ? trunc_sat_(f64|f32)_(s|u)(x) : 0     ->   trunc_sat_(f64|f32)_(s|u)(x)
```

---

### MaxGraey (2021-12-18)

```rust
(x & (1 << y)) != 0     ->      (x >>> y) & 1
(x & (1 << y)) == 0     ->    !((x >>> y) & 1)
```

---

### MaxGraey (2022-06-13)

```rust
(x - y) + y    ->    x
(x + y) - x    ->    y
(x - y) - x    ->    0 - y
```

---

### MaxGraey (2022-06-16)

```rust
(x <op1> y ? C1 :  z) <op2> C2    ->    x <op1> y ? C1 <op2> C2 :  z <op2> C2
(x <op1> y ?  z : C1) <op2> C2    ->    x <op1> y ?  z <op2> C2 : C1 <op2> C2
(x <op1> y ? C1 : C2) <op2> C3    ->    x <op1> y ? C1 <op2> C3 : C1 <op2> C3
```

---

### MaxGraey (2022-07-07)

LLVM doesn't handle this:
```rs
x ? 1 << y : 0    ->    (x != 0) << y
x ? 1 >> y : 0    ->    (x != 0) >> y
x ? 0 : 1 << y    ->    (x == 0) << y
x ? 0 : 1 >> y    ->    (x == 0) >> y
```
```rust
x ? y : y + 1    ->    !x + y
x ? y : y - 1    ->    y - !x
x ? y + 1 : y    ->    (x != 0) + y
x ? y - 1 : y    ->    y - (x != 0)
```

---

### MaxGraey (2022-08-04)

```rust
popcnt(x) ==  0   ->   eqz(x)
popcnt(x) == 32   ->   x == -1
popcnt(x) ==  C   ->   0,       iff  `C < 0` | `C > 32 | 64`
```

---

### MaxGraey (2022-08-10)

```rust
i32(x) < 0 ? i32(y) : 0   ->   (x >> 31) & y
i64(x) < 0 ? i64(y) : 0   ->   (x >> 63) & y
i64(x) < 0 ? i32(y) : 0   ->   (x < 0) & y
i32(x) < 0 ? i64(y) : 0   ->   i64(x >> 31) & y
```

---

### MaxGraey (2022-08-19)

```rust
x * (1 << y)    ->   x << y
(1 << y) * x    ->   x << y
(x << y) / x    ->   1 << y
(x / y) * y     ->   x - (x % y)
x * y           ->   x & y,   iff `x` and `y` are boolean-like
```

---

### MaxGraey (2022-08-25)

```rust
x / y    ->    y ? x : x / 0 ,   iff `maxBits(y) == 1` and `srinkLevel == 0`
x / y    ->    x,                iff `maxBits(y) == 1` and `TrapsNeverHaapen == true`
```

---

### MaxGraey (2022-08-26)

```rust
u64(u32(x)) >>> C     ->    u64(u32(x >>> C)),   iff `(C & 63) < 32`
i64(i32(x)) >> C      ->    i64(i32(x >> C)),    iff `(C & 63) < 32`
u64(u32(x)) >>> C     ->    0,                   iff `(C & 63) >= 32`
i64(i32(x)) >> C      ->    i64(i32(x)) >> 31,   iff `(C & 63) >= 32`
```

---

### MaxGraey (2022-08-27)

reduction:
```rust
x == nan    ->    0
x != nan    ->    1

x >  nan    ->    0
x <  nan    ->    0
x >= nan    ->    0
x <= nan    ->    0
```
any floating point binary operation with NaN on RHS should propagate this NaN as a result
```rust
x + nan   ->   nan
x * nan   ->   nan
...
```
**DONE!**

---

### MaxGraey (2022-08-31)

Found by superoptimizer:
```rust
(x & C_pot) != C_pot    ->    eqz(x & C_pot)

(x & C_pot) == C_pot    ->    (x & C_pot) >>> log2(C_pot)
(x & C_pot) == C_pot    ->    x >>> log2(C_pot),           iff maxBits(x) == log2(C_pot)
(x & C_pot) == C_pot    ->    0,                           iff maxBits(x) < log2(C_pot) && C_pot != 0

,where `C_pot` <- PowOf2(C)
```
```rust
(x >>> C) << C      ->       x & -(1 << C)
(x << C) >>> C      ->       x & (-1 >>> C)
```

---

### MaxGraey (2022-09-01)

It's quite popular pattern which use for checking is bit set or not:
```rust
(x & (1 << y)) != 0      ->     (x >>> y) & 1
```

---

### kripken (2022-09-02)

```wat
(i32.or
 (local.get $0)
 (select
  (i32.const 0)
  (local.get $1)
  (local.get $0)
 )
)
 =->
(select
 (local.get $0)
 (local.get $1)
 (local.get $0)
)
```
Rule `#25` from recent superoptimizer work (#4994). (Not filing a separate issue for this one it doesn't seem to be part of a larger pattern that appears in other rules too, so I'm not sure how to prioritize it.)

---

### kripken (2022-09-02)

Another superoptimizer finding, rule `#26`
```wat
(i32.eq
 (i32.and
  (local.get $0)
  (i32.const 255)
 )
 (i32.const 32)
)
 =->
(i32.eq
 (i32.extend8_s
  (local.get $0)
 )
 (i32.const 32)
)
```

---

### MaxGraey (2022-09-04)

```rust
min(x, x)        ->   x
max(x, x)        ->   x
copysign(x, x)   ->   x
```

---

### MaxGraey (2022-09-17)

```rust
trunc_sat_u(floor(x))   ->   trunc_sat_u(x)
// But `trunc_sat_s` is not valid

trunc_sat_u(trunc(x))   ->   trunc_sat_u(x)
trunc_sat_s(trunc(x))   ->   trunc_sat_s(x)

```

---

### MaxGraey (2022-09-19)

```rust
x == -0.0   ->    x == 0.0
x != -0.0   ->    x != 0.0
x >  -0.0   ->    x >  0.0
x <  -0.0   ->    x <  0.0
x >= -0.0   ->    x >= 0.0
x <= -0.0   ->    x <= 0.0
```

---

### MaxGraey (2023-02-18)

```c++
(unsigned)x == (unsigned)-x     ->     eqz(x << 1)
(signed)x == (signed)-x         ->     eqz(x)
(signed)x != (signed)-x         ->     x != 0
```

---

