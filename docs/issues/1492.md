# #1492: Inlining exported functions, -O vs -O3

- **URL:** https://github.com/WebAssembly/binaryen/issues/1492
- **Author:** dcodeIO
- **Created:** 2018-04-02
- **Updated:** 2018-04-03

## Description

Having the following unoptimized module with an exported and an internal function suitable for inlining:

```wat
(module
 (type $iii (func (param i32 i32) (result i32)))
 (export "add" (func $exported_add))
 (export "test" (func $test))
 (func $exported_add (; 0 ;) (type $iii) (param $0 i32) (param $1 i32) (result i32)
  (i32.add
   (get_local $0)
   (get_local $1)
  )
 )
 (func $internal_sub (; 1 ;) (type $iii) (param $0 i32) (param $1 i32) (result i32)
  (i32.sub
   (get_local $0)
   (get_local $1)
  )
 )
 (func $test (; 2 ;) (type $iii) (param $0 i32) (param $1 i32) (result i32)
  (i32.add
   (call $exported_add
    (get_local $0)
    (get_local $1)
   )
   (call $internal_sub
    (get_local $0)
    (get_local $1)
   )
  )
 )
)
```

When optimizing with default optimization levels, this produces:

```wat
(module
 (type $iii (func (param i32 i32) (result i32)))
 (export "add" (func $exported_add))
 (export "test" (func $test))
 (func $exported_add (; 0 ;) (type $iii) (param $0 i32) (param $1 i32) (result i32)
  (i32.add
   (get_local $0)
   (get_local $1)
  )
 )
 (func $test (; 1 ;) (type $iii) (param $0 i32) (param $1 i32) (result i32)
  (i32.add
   (call $exported_add ;; exported call is not inlined
    (get_local $0)
    (get_local $1)
   )
   (i32.sub ;; internal call is inlined
    (get_local $0)
    (get_local $1)
   )
  )
 )
)
```

Which appears to keep the `call` to the exported function for size reasons (it inlines it in -O3, see below), but it probably should also inline in `-O` because an `i32.add` should always be smaller than a call with an additional function index immediate - is this correct?

For comparison, this is what's produced with `-O3`:

```wat
(module
 (type $iii (func (param i32 i32) (result i32)))
 (export "add" (func $exported_add))
 (export "test" (func $test))
 (func $exported_add (; 0 ;) (type $iii) (param $0 i32) (param $1 i32) (result i32)
  (i32.add
   (get_local $0)
   (get_local $1)
  )
 )
 (func $test (; 1 ;) (type $iii) (param $0 i32) (param $1 i32) (result i32)
  (i32.add
   (i32.add ;; inlined as well
    (get_local $0)
    (get_local $1)
   )
   (i32.sub
    (get_local $0)
    (get_local $1)
   )
  )
 )
)
```

Fwiw, it also doesn't inline this call in `-O2` without a shrinklevel, which seems odd, considering that `-O3s` also doesn't inline it (maybe) for size reasons.

## Comments (5)

### kripken (2018-04-02)

Yeah, we should improve this. It's not quite as simple as this, though:

>  an i32.add should always be smaller than a call with an additional function index immediate - is this correct?

Consider the case where the function flips the argument order,
```
 (func $exported_sub (; 0 ;) (type $iii) (param $0 i32) (param $1 i32) (result i32)
  (i32.sub
   (get_local $1) ;; second arg first
   (get_local $0) ;; first arg second
  )
 )
```
If in addition the arguments passed have side effects, then we need to create a block, assign to a temporary local, etc., so that we keep the side effects in the right order. (Whereas when it's not exported, we know we can remove the function, so even if we need that extra overhead it's going to be worth it for size. And when we do `-O3` we don't care about size and focus on reducing the call overhead, so we do inline even if it is exported.)

It's tricky to get those things correct. Maybe the simplest thing is to simply inline and measure the size after optimizations, but that's not going to be fast. Alternatively, we could focus on getting simple cases right like this one, maybe that's worth doing - is this common, do you think?

---

### dcodeIO (2018-04-02)

Thanks, makes sense.

> Alternatively, we could focus on getting simple cases right like this one

Hmm, when I think about it a bit that might already be sufficient because it must be a simple case to be worth it anyway, if I understood this correctly. Like replacing a call with an add just to save the immediate. Didn't quite understand the implications of flipping arguments, unfortunately, so I might still be missing something.

---

### kripken (2018-04-03)

This is the flipping problem: given this,
```
(func $small (param $x i32) (param $y i32) (result i32)
  (i32.sub
    (get_local $y)
    (get_local $x)
  )
)
(func $big
...
  (call $small
    (call $first-side-effect)
    (call $second-side-effect)
  )
...
)
```
If we inline we must keep the order of those two calls the same as before. So we need something like this:
```
(func $big
...
  (block
    (set_local $temp_first_side_effect
      (call $first-side-effect)
    )
    (i32.sub
      (call $second-side-effect)
      (get_local $temp_first_side_effect)
    )
  )
...
)
```
I can't think of a more efficient way to do that. And it's larger than the call, sadly.

---

### dcodeIO (2018-04-03)

Thanks, now I hopefully understand. So, it appears to me that inlining could be safely performed without introducing a block if either of the following conditions is met:

1. arguments are in the same order
2. arguments are flipped but the second that becomes the first doesn't write to a var or memory or call a function that might do so (except its own locals)
3. arguments are flipped but the first that becomes the second doesn't read from a var or memory or call a function that might do so (except its own locals)

Obviously, 1) already catches the case outlined above, but so would 2) because there's no write, but not 3) because there are reads.

Does that make sense? :)

---

### kripken (2018-04-03)

Exactly, yeah. For 2&3 we have EffectAnalyzer so it's easy to see if two arguments can be flipped without problems. For 1, we actually don't have a simple interface for it, no way to abstract "give me the operands without caring about the node type". Might be worth doing that first.

What I kind of don't like is that even with that interface, this would be very specific to the case of a function with a single node that has 2 operands (so a binary node or a call etc.). There are going to be more cases of various sorts. So it would be nice to have a very general way to see if an inlining is going to be worth it or not, but that's hard. At the same time, we should handle common cases at least, so I'm not opposed to doing this for this specific case.

---

