# #2321: Allow using Asyncify functions from a shared module

- **URL:** https://github.com/WebAssembly/binaryen/issues/2321
- **Author:** RReverser
- **Created:** 2019-08-30
- **Updated:** 2019-09-05

## Description

As discussed with @kripken earlier today, currently two asyncified WebAssembly modules can't properly interact with each other, because each gets own `asyncify_*` methods and a global state.

This means that, when module A calls into a module B, and module B schedules an async operation and starts unwinding, the unwinding ends in the module B, and module A thinks that the call has succeeded and finished.

To fix this, we need to allow sharing Asyncify between different modules by providing a single entry point for the implementation that would be imported by all the others.

As a bonus, this would also reduce code duplication between different modules when code splitting and could allow making the Asyncify API implementation more isolated by using a separate memory and not clashing with real linear memory of other modules.

## Comments (8)

### RReverser (2019-08-31)

One important clarification: the problem described above doesn't really apply for regular imports/exports. In case they're correctly wrapped on both sides by Asyncify JS wrapper, exports of module B will look like regular async functions when imported into module A, and so each module will correctly unwind/rewind on its own even without a shared state.

The issue arises when one uses WebAssembly tables, because these can be shared between modules, and each module can put arbitrary functions directly into the table. These functions can be set directly from within Wasm code, so they won't be handled by Asyncify wrapper and will run into issue described above when invoked across modules.

The only fix for this case is sharing a global state as described above.

---

### kripken (2019-09-03)

Thinking more about this, maybe it can almost already work, if everything is driven by JS from the outside (or another wasm module; but being driven by JS is how emscripten currently works).

That is, each module already exports `asyncify_start_unwind` etc. and has its own internal global for the asyncify state and data. If a sleep begins, then JS can call **all** the wasm modules to update them about that event, and so forth.

In other words, in this model JS decides when a sleep beings and ends, and it's a performance optimization that each module has internal globals.

---

### RReverser (2019-09-04)

@kripken Hmm, you seem to be still talking about regular imported/exported functions, right? In that case, yes, it would be just an optimisation. But I don't see how it addresses the problem I described earlier and in https://github.com/WebAssembly/binaryen/issues/2321#issuecomment-526814361 somehow?

The problem with that case currently is an indirection, where one module can call directly into the other one, without any JS layer in between - that is, JS can't even detect or intercept such calls.

That is fixable as described above, but still needs some work to get there.

---

### kripken (2019-09-04)

I may not be understanding you, then, sorry. Re-reading this entire issue to try again, I'm not sure I understand what you mean by "wrapping" in the second comment, so maybe I misunderstood that entire comment?

I also don't quite see what "regular" means in your last comment, sorry.

Assuming I understood the very first comment here, then I do think what I suggested allows that to work: when one module calls a JS import that starts a sleep, that JS import will notify all wasm modules to unwind, and so unwinding will proceed all the way to the bottom (the JS must know when it gets there, but the wasms will unwind to there). So it doesn't matter in that case if there is one wasm module or multiple wasm modules, unwinding works the same (if JS notified all of them).

---

### RReverser (2019-09-04)

Sorry, maybe I don't understand your idea either. How does JS know which modules to unwind and in which order? Does it keep track of all the loaded Wasm modules? 

---

### kripken (2019-09-04)

Yes, JS would need to be aware of all the relevant modules. (That is the case right now, trivially, in emscripten, as the JS has its singleton wasm module.)

If you want some JS to be aware of just some wasm modules and not others, but be able to sleep across those too, then that does sound hard... but it's also unclear to me what the use case is there. I'm probably too focused on the simple case though...

---

### RReverser (2019-09-05)

Just to be sure - if I understand your idea right, by "notifying" you're suggesting that JS will tell all Wasm modules to change their async_state to Unwinding / Rewinding, and then calls will work as normal, without sharing the actual variable, because state is synchronised anyway? 

If so, yeah, that would also work. Just not sure if it's simpler than actually sharing the underlying state via imports/exports. Let me play around and see how hard would it be to implement. 

---

### kripken (2019-09-05)

Yes, exactly.

I think an advantage to not sharing the state is that sharing would either require shared mutable globals (which are not standard everywhere, especially not off the web), or doing slow calls to the outside. On the other hand, changing the async state is rare, so notifying all modules at that time isn't so costly. And this seems simple as it uses the existing code for everything (just JS would call more modules).

---

