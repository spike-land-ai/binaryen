# #2468: [Feature] Evaluated case elimination pass

- **URL:** https://github.com/WebAssembly/binaryen/issues/2468
- **Author:** MaxGraey
- **Created:** 2019-11-25
- **Updated:** 2019-11-25

## Description

```ts
function test(x: i32) : i32 {
  switch (x) {
    case 1: return 2;
    case 2: return 2;
  }
  return 2;
}
```
current with `-O4`:
```wat
  (func $test (export "test") (type $t0) (param $p0 i32) (result i32)
    block $B0
      block $B1
        get_local $p0
        i32.const 1
        i32.ne
        if $I2
          get_local $p0
          i32.const 2
          i32.eq
          br_if $B1
          br $B0
        end
        i32.const 2
        return
      end
      i32.const 2
      return
    end
    i32.const 2)
```
optimal (with evaluated case elimination transform):
```wat
(func $test (export "test") (type $t0) (param $p0 i32) (result i32)
   i32.const 2
)
```

## Comments (6)

### tlively (2019-11-25)

Can you describe the transform you have in mind more generally? My best guess for a pass that would accomplish this would involve abstract interpretation.

---

### MaxGraey (2019-11-25)

[paper](https://nbviewer.jupyter.org/github/grin-compiler/grin/blob/master/papers/boquist.pdf#page=141)

Additional different strategies described also in this paper: https://llvm.org/pubs/2007-05-31-Switch-Lowering.pdf

---

### tlively (2019-11-25)

Cool! PRs very welcome if youâ€™re interested in working on these. 

---

### MaxGraey (2019-11-25)

@tlively I will try but I'm little scary modern C++ and its build system)

---

### kripken (2019-11-25)

I don't fully understand the general problem here, but for that specific testcase, all the returns are of `2`? Optimizing that should be done in [`optimizeTerminatingTails in CodeFolding](https://github.com/WebAssembly/binaryen/blob/d90583cf509c3f21b3b5136d3872b097c5f2800c/src/passes/CodeFolding.cpp#L528). The "is it worth it" part may think that if the only code to be folded is a single constant, then it's not worth it. I'd suggest adding some debug printouts there, and seeing what happens when you change things.

---

### MaxGraey (2019-11-25)

Thanks @kripken! I saw a lot of TODOs here. May be just need finish that's missing parts, hmm. The basic Idea is optimize code like this:
```ts
export function test(x: i32, c: i32) : i32 {
  switch (x) {
    case 1: return 3 * c + 2;
    case 2: return 3 * c + 2;
    case 3: return 3 * c + 2;
    case 4: return 3 * c + 2;
  }
  return 3 * c + 2;
}
``` 
to
```ts
export function test2(x: i32, c: i32) : i32 {
  switch (x) {
    case 1:
    case 2:
    case 3:
    case 4: 
    default: return 3 * c + 2;
  }
}
```
just compare case's body or (it's hashes).

which produce this result:
```wat
(func $test2 (export "test2") (type $t0) (param $p0 i32) (param $p1 i32) (result i32)
    block $B0
      block $B1
        get_local $p0
        i32.const 1
        i32.sub
        br_table $B0 $B0 $B0 $B0 $B1
      end
    end
    get_local $p1
    i32.const 3
    i32.mul
    i32.const 2
    i32.add)
```
Not optimal but much better than untransformed version. More optimal of course just return `i32.const 2`. 


---

